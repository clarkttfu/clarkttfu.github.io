{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"中文","n":1}}},{"i":2,"$":{"0":{"v":"名人警句","n":1},"1":{"v":"\n$~$\n\n> 你不要用战术上的勤奋掩盖战略上的懒惰。  \n-- 雷军\n","n":0.5}}},{"i":3,"$":{"0":{"v":"理解 OAuth2","n":0.707},"1":{"v":"\n## 基本概念\n\nOAuth2解决了使用通用的账户系统，授权并登陆第三方程序的问题。比如使用新浪微博账号登陆知乎，比如使用google账户登陆stackoverflow。\n\n### 角色(Roles)\n- resource owner: 受保护信息资源的拥有者，比如新浪微博的用户，以下简称Owner\n- resource server: 受保护资源的提供者，比如新浪微博，以下简称Server\n- client: 第三方应用或者网站，比如知乎，以下简称Client\n- authorization server: 授权服务器，可以是resource server本身或者单独出现，比如新浪微博登录API，以下简称Auth\n  - authorize API (endpoint): 验证Owner，发放Auth Code，须支持GET请求\n  - token API (endpoint): 验证Client，发放Token\n\n### User Agent\n\n授权流程中User Agent就是你使用的浏览器或者App。Client或者Auth通过重定向User Agent到不同的URL完成授权过程，所以它是整个授权过程中的交互核心，详见[授权类型](#授权类型)中的时序图描述部分。\n\n### Token\n\n#### Acess Token\n\nAccess Token是整个授权流程的最终目标。第三方Client从Auth成功获取后便可以使用它访问受保护Server资源。通常情况下Access Token是一个经过Hash或者加密的字符串([Bear Token - RFC6750](https://tools.ietf.org/html/rfc6750))，其内容对第三方Client不透明(opaque，即第三方Client无须关注其内容构成)。它本身可以包含经过签名（以便Resource Server验证）的完整的授权信息，也可以只是完整授权信息的id。\n\nClient取得Token后通常将其作为Header设给Authroziation:\n\n```\n# bear类型\nAuthorization: Bearer mF_9.B5f-4.1JqM\n# mac类型\nAuthorization: MAC id=\"h480djs93hd8\",nonce=\"274312:dj83hs9s\",mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n```\n\n\n#### Refresh Token\n\nAuth可以在返回Access Token时附上Refresh Token，以便当Access Token过期或者失效后使用Refresh Token获取新的Access Token。Refresh Token的发放是**可选的**，且仅由Auth返回给Client，它不应该被发送给Server。\n\n#### (Access Token) Scope\n\n授权请求的可选参数，用于限定授权范围，通常为空格分隔的大小写敏感的列表字符串。具体的scope列表应该有Auth设计提供。Auth可以完全忽略请求中的scope，或者返回和请求不一致的scope。\n\n### HTTPS\n\nOAuth2强调必须使用HTTPS，否则明文传输auth code，token或者Client密码存在极大安全隐患。\n\n### Client注册\n\n第三方Client根据类型需要向Auth注册以通过[授权码方式中步骤D](#Authorization Code)的验证，进一步提升安全性，保护Refresh Token。\n\n注册内容通常有：\n\n- client_id: Auth上唯一表示该Client的字符串\n- client_secret: 密码或者秘钥对。\n- client type: 两种客户端类型之一，如果构成复杂则需要分开注册\n  - confidential: 可以安全保存秘钥凭据的实现，比如web后端\n  - public: 运行在Owner设备上的应用，比如单页应用，本地桌面程序\n- redirection URIs: 请求完成是浏览器跳转返回的链接，URI越完整越安全。如果Client没有注册，Auth请求中必须包含redirect_uri。\n\n其中必须注册的Client包括：\n- 使用[Implicit授权](#Implicit授权)的confidential类型\n- public类型\n\n规范中Auth必须支持HTTP Basic Auth进行Client密码校验。\n\n\n## 授权类型\n\n### 授权码授权 (Authorization Code Grant)\n\n> the transmission of the access token directly to the client without\n  passing it through the resource owner's user-agent and potentially\n  exposing it to others, including the resource owner.\n\n安全性最高的授权模式：最终的访问令牌直接发送给client程序，绕过了UserAgent(浏览器)，所以无论是你自己或者任何浏览器中运行的其它程序均无法获得。\n\n\n#### 流程\n\n``` mermaid\nsequenceDiagram\n    participant O as Resource Owner\n    participant C as Client\n    participant UA as User Agent\n    participant AS as Auth Server\n\n    C->>+UA: A1. 使用新浪微博登陆知乎\n    \n    UA->>+AS: A2. 知乎重定向浏览器到新浪微博登录页并附加请求信息：\n    Note over UA, AS: response_type=code client_id [redirect_uri] [scope] [state]\n\n    O->>AS: B. 在浏览器中登录新浪微博，验证授权请求scope，比如获取你的邮箱\n\n    AS-->>-UA: C1. 浏览器重定向到步骤A中的redirect_uri\n    Note over UA, AS: 附加至查询参数:code=xx&state=xx 或失败:error=access_denied&state=xx\n\n    UA-->>-C: C2. 知乎JS应首先执行，从URI中获取并删除auth code\n\n    C->>+AS: D. POST请求：用code换access token\n    Note over UA: code grant_type client_id redirect_uri \n\n    AS->>AS: authenticate client, validate code/redirect-uri\n\n    AS-->>-C: E. access token, optional refresh token in body\n```\n\n#### HTTP请求示例\n\n```\n# Client授权请求，浏览器被重定向到登录页面\nhttps://authorization-server.com/auth?response_type=code&\n  client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx\n\n# 登录、授权成功，Auth使用以下链接将浏览器重定向回Client\nhttps://example-app.com/cb?code=AUTH_CODE_HERE&state=1234zyx\n\n# Client使用code换取Access Token\nPOST https://api.authorization-server.com/token\n  grant_type=authorization_code&\n  code=AUTH_CODE_HERE&\n  redirect_uri=REDIRECT_URI&\n  client_id=CLIENT_ID&\n  client_secret=CLIENT_SECRET\n```\n\n\n### 隐式授权 (Implicit Grant)\n\n> simplified authorization code flow optimized for clients implemented in a browser using a\n  scripting language such as JavaScript.\n\n一步完成Access Token获取，无须显式Client验证（仅通过redirection URI隐式验证）。Access Token会被加入redirection URI fragment(#哈希部分），并存留于User Agent，降低了安全性。\n\n**该授权方式最早为为单页应用设计，但目前在新版规范中已经废弃！请使用code授权方式，但是不使用client secrect。即在使用code换取token时，不使用client_secrect**\n\n#### HTTP请求示例\n\n```\n# Client授权请求\nhttps://authorization-server.com/auth?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&scope=photos&state=1234zyx\n\n# Auth 端在Client成功授权后，对浏览器重定向\nhttps://example-app.com/cb?code=AUTH_CODE_HERE&state=1234zyx\n\n# Client使用code换取Access Token\nPOST https://api.authorization-server.com/token\n  grant_type=authorization_code&\n  code=AUTH_CODE_HERE&\n  redirect_uri=REDIRECT_URI&\n  client_id=CLIENT_ID\n```\n\n### 客户程序凭证授权(Client Credentials Grant)\n\n第三方程序(Client)通过已经注册的凭证直接向Auth申请Access Token以访问由自己控制的资源(比如API)。\n\n最常见的情况为[微信小程序可以获取Access Token的过程](https://developers.weixin.qq.com/miniprogram/dev/api/token.html#%E8%8E%B7%E5%8F%96-accesstoken)：\n\n```\nGET 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appId=xxxxxxxxx&secret=xxxxxxxxxxxxx'\n```\n\n### 资源所有者密码授权(Resource Owner Password Credentials Grant)\n\n当且仅当资源所有者与第三方程序有极强的信任关系，或者第三方为高优先级程序(比如操作系统)时才可以使用的授权方式。\n另外一种情况就是讲已有的凭证进行转换升级，比如将已经保存的老版本OAuth凭据转换为Access Token。\n\n\n## 参考文章\n\n- [The OAuth 2.0 Authorization Framework - RFC6749](https://tools.ietf.org/html/rfc6749)\n- [理解OAuth 2.0 - 阮一峰](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n- [Understanding OAuth2](http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/)\n- [OAuth 2 Simplified](https://aaronparecki.com/oauth-2-simplified/)\n","n":0.061}}},{"i":4,"$":{"0":{"v":"PKI","n":1}}},{"i":5,"$":{"0":{"v":"ASN.1","n":1},"1":{"v":"\n[X.690](https://en.wikipedia.org/wiki/X.690#BER_encoding) is an ITU-T standard specifying several ASN.1 encoding formats:\n\n- Basic Encoding Rules (BER)\n- Distinguished Encoding Rules (DER), derived from BER\n- Canonical Encoding Rules (CER) (not concerned in this series articles)\n\n## Basic Structure\n\nType–length–value (TLV) encodings:\n\nIdentifier octets | Length octets | Contents octets | End-of-contents octets\n--                | --            | --              | --\nType\t            | Length        | *optional* Value  | *optional*\n\n### Identifier\n\n\n\n\n2A 86  48 86 F7 0D 01 07 02","n":0.122}}},{"i":6,"$":{"0":{"v":"Shell","n":1},"1":{"v":"\nEverthing about shell","n":0.577}}},{"i":7,"$":{"0":{"v":"Expect","n":1},"1":{"v":"\n[Tcl commands](https://www.tcl.tk/man/tcl/TclCmd/contents.html)\n[Tcl tutorial](https://www.tcl.tk/man/tcl8.5/tutorial/tcltutorial.html)\n\n```\n#!/usr/bin/expect -f\n\nset suffix [lindex $argv 0]\nif { [string length $suffix] < 1 } {\n  puts \"target vm is required\"\n  exit 1\n}\n\nset     ip \"192.168.122.\"\nappend  ip \"$suffix\"\n\nset     userid root\nset     passwd root\nset     timeout 10\n\nset prompt \"\\[root@sylixos:/root\\]# \"\n\nputs   \"Telnet $ip ...\"\n\nspawn telnet $ip\n    expect \"login: \"\n    send \"$userid\\r\"\n\n    expect \"password: \"\n    send \"$passwd\\r\"\n\n    interact\n```","n":0.139}}},{"i":8,"$":{"0":{"v":"Network","n":1},"1":{"v":"\nIn honor of:\n\n- [Bill Joy](https://en.wikipedia.org/wiki/Bill_Joy)\n- [Richard Stevens](https://en.wikipedia.org/wiki/W._Richard_Stevens)","n":0.378}}},{"i":9,"$":{"0":{"v":"DHCP","n":1},"1":{"v":"\n\n\nThe design of DHCP is based on an earlier protocol called the Internet Bootstrap Protocol (BOOTP) [RFC0951][RFC1542].\nBOOTP and DHCP are backward-compatible in the sense that BOOTP-only clients can make use of DHCP servers and DHCP clients can make use of BOOTP-only servers. \n\nBOOTP, and therefore DHCP as well, is carried using UDP/IP.\n\nDHCP comprises two major parts: \n1. address management.\n  - dynamic allocation: allocate (from pool) and revoke (on lease expiration)\n  - automatic allocation: allocate (from pool) without revoking\n  - manual allocation: fix the address (not from pool) for client \n2. delivery of configuration data.\n\n![BOOTP/DHCP Packet](/assets/images/network.dhcp.png)\n- **DHCP Option** is carried inside \"Server Name\" & \"Boot File Name\" field.\n- \n","n":0.096}}},{"i":10,"$":{"0":{"v":"Quotes","n":1},"1":{"v":"\n$~$\n\nMay 10th, 2022\n> Promgramming language is just like human languange, one have to speak\nnatively to get evolved in the real business.\n-- Blogger\n\nDay 0\n\n> Simplicity is the ultimate sophistication.  \n-- Leonardo da Vinci\n","n":0.177}}}]}
